searchNodes=[{"ref":"Banking.html","title":"Banking","type":"module","doc":"Banking keeps the contexts that define your domain and business logic. Contexts are also responsible for managing your data, regardless if it comes from the database, an external API or others."},{"ref":"Banking.AccountManagement.html","title":"Banking.AccountManagement","type":"module","doc":"Works as a public API to handle all the operations regarding user registration and account administration."},{"ref":"Banking.AccountManagement.html#create/1","title":"Banking.AccountManagement.create/1","type":"function","doc":"Register a user with the following fields: name - The FULL NAME of the user. email password - Must have length between 8 and 128 characters, contains a number, an upper-case, a lower-case and a symbol birthday document_id with document_type - The document if for the given type that could be of the following: cpf, rg, passport or cnpj."},{"ref":"Banking.AccountManagement.html#disable/1","title":"Banking.AccountManagement.disable/1","type":"function","doc":"Block a given account"},{"ref":"Banking.AccountManagement.html#enable/1","title":"Banking.AccountManagement.enable/1","type":"function","doc":"Enable a given account"},{"ref":"Banking.AccountManagement.html#get/1","title":"Banking.AccountManagement.get/1","type":"function","doc":"Get an account by his id."},{"ref":"Banking.AccountManagement.html#get_by_public_id/1","title":"Banking.AccountManagement.get_by_public_id/1","type":"function","doc":"Get the account by the public available UUID"},{"ref":"Banking.AccountManagement.html#validate_email/1","title":"Banking.AccountManagement.validate_email/1","type":"function","doc":"Validate the email by moving pending_email to the main email field. If the user has a pending confirmation account associated then this account will be activated."},{"ref":"Banking.AccountManagement.html#verify_password/2","title":"Banking.AccountManagement.verify_password/2","type":"function","doc":"Verifies the hashed password from the user against the raw password"},{"ref":"Banking.Bank.html","title":"Banking.Bank","type":"module","doc":"Processes all the financial operations and make an immutable register them as transactions."},{"ref":"Banking.Bank.html#add_bonus/2","title":"Banking.Bank.add_bonus/2","type":"function","doc":"Add funds to a given account Example: iex&gt; Bank.withdrawal(account, 10) {:ok, %{ bank_transaction: %Banking.Bank.Transaction{ __meta__: #Ecto.Schema.Metadata&lt;:loaded, &quot;bank_transactions&quot;&gt;, amount: #Decimal&lt;1000&gt;, id: 3, inserted_at: ~N[2019-11-28 04:40:42], public_id: &quot;9086a2b5-7f21-494b-9d83-28c2a10d0432&quot;, source_id: 1, target_id: 4, updated_at: ~N[2019-11-28 04:40:42] }}"},{"ref":"Banking.Bank.html#transfer/3","title":"Banking.Bank.transfer/3","type":"function","doc":"Transfer money from the source account to the target. Example: iex&gt; Bank.transfer(source_account, target_account, 100) {:ok, %{ bank_transaction: %Banking.Bank.Transaction{ __meta__: #Ecto.Schema.Metadata&lt;:loaded, &quot;bank_transactions&quot;&gt;, amount: #Decimal&lt;100&gt;, id: 1, inserted_at: ~N[2019-11-28 04:36:24], public_id: &quot;54469e74-79da-468c-aafc-6a0bbfb4af8e&quot;, source_id: 4, target_id: 5, updated_at: ~N[2019-11-28 04:36:24] }}"},{"ref":"Banking.Bank.html#withdrawal/2","title":"Banking.Bank.withdrawal/2","type":"function","doc":"Withdrawal money from a given account Example: iex&gt; Bank.withdrawal(account, 10) {:ok, %{ bank_transaction: %Banking.Bank.Transaction{ __meta__: #Ecto.Schema.Metadata&lt;:loaded, &quot;bank_transactions&quot;&gt;, amount: #Decimal&lt;10&gt;, id: 2, inserted_at: ~N[2019-11-28 04:37:54], public_id: &quot;c5f3e493-11c4-4703-82c7-c001f7294619&quot;, source_id: 4, target_id: 2, updated_at: ~N[2019-11-28 04:37:54] }}"},{"ref":"Banking.Bank.SpecialAccounts.html","title":"Banking.Bank.SpecialAccounts","type":"module","doc":"Keep track of the special accounts that are used as registers to share the same interface of common transactions. This solution might change in the future when in the case of supporting multiple banks or more complex operations."},{"ref":"Banking.Bank.SpecialAccounts.html#bank_reserves/0","title":"Banking.Bank.SpecialAccounts.bank_reserves/0","type":"function","doc":"Returns the account that represents the bank reserve."},{"ref":"Banking.Bank.SpecialAccounts.html#cashout/0","title":"Banking.Bank.SpecialAccounts.cashout/0","type":"function","doc":"Returns the account that register all the money that was withdrawn in the bank."},{"ref":"Banking.Bank.SpecialAccounts.html#fees/0","title":"Banking.Bank.SpecialAccounts.fees/0","type":"function","doc":"Returns the account that register all the money paid as a bank fee. This is very useful as placeholder to be placed in the transaction table."},{"ref":"Banking.Repo.html","title":"Banking.Repo","type":"module","doc":""},{"ref":"Banking.Repo.html#aggregate/4","title":"Banking.Repo.aggregate/4","type":"function","doc":"Calculate the given aggregate over the given field. If the query has a limit, offset or distinct set, it will be automatically wrapped in a subquery in order to return the proper result. Any preload or select in the query will be ignored in favor of the column being aggregated. The aggregation will fail if any group_by field is set. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. See the &quot;Shared options&quot; section at the module documentation for more options. Examples # Returns the number of visits per blog post Repo.aggregate(Post, :count, :visits) # Returns the number of visits per blog post in the &quot;private&quot; schema path # (in Postgres) or database (in MySQL) Repo.aggregate(Post, :count, :visits, prefix: &quot;private&quot;) # Returns the average number of visits for the top 10 query = from Post, limit: 10 Repo.aggregate(query, :avg, :visits) Callback implementation for Ecto.Repo.aggregate/4."},{"ref":"Banking.Repo.html#all/2","title":"Banking.Repo.all/2","type":"function","doc":"Fetches all entries from the data store matching the given query. May raise Ecto.QueryError if query validation fails. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. See the &quot;Shared options&quot; section at the module documentation for more options. Example # Fetch all post titles query = from p in Post, select: p.title MyRepo.all(query) Callback implementation for Ecto.Repo.all/2."},{"ref":"Banking.Repo.html#checkout/2","title":"Banking.Repo.checkout/2","type":"function","doc":"Checks out a connection for the duration of the function. It returns the result of the function. This is useful when you need to perform multiple operations against the repository in a row and you want to avoid checking out the connection multiple times. checkout/2 and transaction/2 can be combined and nested multiple times. If checkout/2 is called inside the function of another checkout/2 call, the function is simply executed, without checking out a new connection. Options See the &quot;Shared options&quot; section at the module documentation for more options. Callback implementation for Ecto.Repo.checkout/2."},{"ref":"Banking.Repo.html#child_spec/1","title":"Banking.Repo.child_spec/1","type":"function","doc":""},{"ref":"Banking.Repo.html#config/0","title":"Banking.Repo.config/0","type":"function","doc":"Returns the adapter configuration stored in the :otp_app environment. If the c:init/2 callback is implemented in the repository, it will be invoked with the first argument set to :runtime. Callback implementation for Ecto.Repo.config/0."},{"ref":"Banking.Repo.html#delete/2","title":"Banking.Repo.delete/2","type":"function","doc":"Deletes a struct using its primary key. If the struct has no primary key, Ecto.NoPrimaryKeyFieldError will be raised. If the struct has been removed from db prior to call, Ecto.StaleEntryError will be raised. It returns {:ok, struct} if the struct has been successfully deleted or {:error, changeset} if there was a validation or a known constraint error. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any @schema_prefix set in the schema. :stale_error_field - The field where stale errors will be added in the returning changeset. This option can be used to avoid raising Ecto.StaleEntryError. :stale_error_message - The message to add to the configured :stale_error_field when stale errors happen, defaults to &quot;is stale&quot;. See the &quot;Shared options&quot; section at the module documentation for more options. Example post = MyRepo.get!(Post, 42) case MyRepo.delete post do {:ok, struct} -&gt; # Deleted with success {:error, changeset} -&gt; # Something went wrong end Callback implementation for Ecto.Repo.delete/2."},{"ref":"Banking.Repo.html#delete!/2","title":"Banking.Repo.delete!/2","type":"function","doc":"Same as c:delete/2 but returns the struct or raises if the changeset is invalid. Callback implementation for Ecto.Repo.delete!/2."},{"ref":"Banking.Repo.html#delete_all/2","title":"Banking.Repo.delete_all/2","type":"function","doc":"Deletes all entries matching the given query. It returns a tuple containing the number of entries and any returned result as second element. The second element is nil by default unless a select is supplied in the delete query. Note, however, not all databases support returning data from DELETEs. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any @schema_prefix set in the schema. See the &quot;Shared options&quot; section at the module documentation for remaining options. Examples MyRepo.delete_all(Post) from(p in Post, where: p.id &lt; 10) |&gt; MyRepo.delete_all Callback implementation for Ecto.Repo.delete_all/2."},{"ref":"Banking.Repo.html#exists?/2","title":"Banking.Repo.exists?/2","type":"function","doc":"Checks if there exists an entry that matches the given query. Returns a boolean. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. See the &quot;Shared options&quot; section at the module documentation for more options. Examples # checks if any posts exist Repo.exists?(Post) # checks if any posts exist in the &quot;private&quot; schema path (in Postgres) or # database (in MySQL) Repo.exists?(Post, schema: &quot;private&quot;) # checks if any post with a like count greater than 10 exists query = from p in Post, where: p.like_count &gt; 10 Repo.exists?(query) Callback implementation for Ecto.Repo.exists?/2."},{"ref":"Banking.Repo.html#get/3","title":"Banking.Repo.get/3","type":"function","doc":"Fetches a single struct from the data store where the primary key matches the given id. Returns nil if no result was found. If the struct in the queryable has no or more than one primary key, it will raise an argument error. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. See the &quot;Shared options&quot; section at the module documentation for more options. Example MyRepo.get(Post, 42) MyRepo.get(Post, 42, prefix: &quot;public&quot;) Callback implementation for Ecto.Repo.get/3."},{"ref":"Banking.Repo.html#get!/3","title":"Banking.Repo.get!/3","type":"function","doc":"Similar to c:get/3 but raises Ecto.NoResultsError if no record was found. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. See the &quot;Shared options&quot; section at the module documentation for more options. Example MyRepo.get!(Post, 42) MyRepo.get!(Post, 42, prefix: &quot;public&quot;) Callback implementation for Ecto.Repo.get!/3."},{"ref":"Banking.Repo.html#get_by/3","title":"Banking.Repo.get_by/3","type":"function","doc":"Fetches a single result from the query. Returns nil if no result was found. Raises if more than one entry. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. See the &quot;Shared options&quot; section at the module documentation for more options. Example MyRepo.get_by(Post, title: &quot;My post&quot;) MyRepo.get_by(Post, [title: &quot;My post&quot;], prefix: &quot;public&quot;) Callback implementation for Ecto.Repo.get_by/3."},{"ref":"Banking.Repo.html#get_by!/3","title":"Banking.Repo.get_by!/3","type":"function","doc":"Similar to c:get_by/3 but raises Ecto.NoResultsError if no record was found. Raises if more than one entry. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. See the &quot;Shared options&quot; section at the module documentation for more options. Example MyRepo.get_by!(Post, title: &quot;My post&quot;) MyRepo.get_by!(Post, [title: &quot;My post&quot;], prefix: &quot;public&quot;) Callback implementation for Ecto.Repo.get_by!/3."},{"ref":"Banking.Repo.html#get_dynamic_repo/0","title":"Banking.Repo.get_dynamic_repo/0","type":"function","doc":"Returns the atom name or pid of the current repository. See c:put_dynamic_repo/1 for more information. Callback implementation for Ecto.Repo.get_dynamic_repo/0."},{"ref":"Banking.Repo.html#in_transaction?/0","title":"Banking.Repo.in_transaction?/0","type":"function","doc":"Returns true if the current process is inside a transaction. If you are using the Ecto.Adapters.SQL.Sandbox in tests, note that even though each test is inside a transaction, in_transaction?/0 will only return true inside transactions explicitly created with transaction/2. This is done so the test environment mimics dev and prod. If you are trying to debug transaction-related code while using Ecto.Adapters.SQL.Sandbox, it may be more helpful to configure the database to log all statements and consult those logs. Examples MyRepo.in_transaction? #=&gt; false MyRepo.transaction(fn -&gt; MyRepo.in_transaction? #=&gt; true end) Callback implementation for Ecto.Repo.in_transaction?/0."},{"ref":"Banking.Repo.html#insert/2","title":"Banking.Repo.insert/2","type":"function","doc":"Inserts a struct defined via Ecto.Schema or a changeset. In case a struct is given, the struct is converted into a changeset with all non-nil fields as part of the changeset. In case a changeset is given, the changes in the changeset are merged with the struct fields, and all of them are sent to the database. It returns {:ok, struct} if the struct has been successfully inserted or {:error, changeset} if there was a validation or a known constraint error. Options :returning - selects which fields to return. It accepts a list of fields to be returned from the database. When true, returns all fields. When false, no extra fields are returned. It will always include all fields in read_after_writes as well as any autogenerated id. Not all databases support this option. :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any @schema_prefix set any schemas. Also, the @schema_prefix for the parent record will override all default @schema_prefixs set in any child schemas for associations. :on_conflict - It may be one of :raise (the default), :nothing, :replace_all, :replace_all_except_primary_key, {:replace, fields}, a keyword list of update instructions or an Ecto.Query query for updates. See the &quot;Upserts&quot; section for more information. :conflict_target - A list of column names to verify for conflicts. It is expected those columns to have unique indexes on them that may conflict. If none is specified, the conflict target is left up to the database. May also be {:constraint, constraint_name_as_atom} in databases that support the &quot;ON CONSTRAINT&quot; expression, such as PostgreSQL. :stale_error_field - The field where stale errors will be added in the returning changeset. This option can be used to avoid raising Ecto.StaleEntryError. :stale_error_message - The message to add to the configured :stale_error_field when stale errors happen, defaults to &quot;is stale&quot;. See the &quot;Shared options&quot; section at the module documentation for more options. Examples A typical example is calling MyRepo.insert/1 with a struct and acting on the return value: case MyRepo.insert %Post{title: &quot;Ecto is great&quot;} do {:ok, struct} -&gt; # Inserted with success {:error, changeset} -&gt; # Something went wrong end Upserts c:insert/2 provides upserts (update or inserts) via the :on_conflict option. The :on_conflict option supports the following values: :raise - raises if there is a conflicting primary key or unique index :nothing - ignores the error in case of conflicts :replace_all - replace all values on the existing row with the values in the schema/changeset, including autogenerated fields such as inserted_at and updated_at :replace_all_except_primary_key - same as above except primary keys are not replaced {:replace, fields} - replace only specific columns. This option requires conflict_target a keyword list of update instructions - such as the one given to c:update_all/3, for example: [set: [title: &quot;new title&quot;]] an Ecto.Query that will act as an UPDATE statement, such as the one given to c:update_all/3. If the struct cannot be found, Ecto.StaleEntryError will be raised. Upserts map to &quot;ON CONFLICT&quot; on databases like Postgres and &quot;ON DUPLICATE KEY&quot; on databases such as MySQL. As an example, imagine :title is marked as a unique column in the database: {:ok, inserted} = MyRepo.insert(%Post{title: &quot;this is unique&quot;}) Now we can insert with the same title but do nothing on conflicts: {:ok, ignored} = MyRepo.insert(%Post{title: &quot;this is unique&quot;}, on_conflict: :nothing) assert ignored.id == nil Because we used on_conflict: :nothing, instead of getting an error, we got {:ok, struct}. However the returned struct does not reflect the data in the database. One possible mechanism to detect if an insert or nothing happened in case of on_conflict: :nothing is by checking the id field. id will be nil if the field is autogenerated by the database and no insert happened. For actual upserts, where an insert or update may happen, the situation is slightly more complex, as the database does not actually inform us if an insert or update happened. Let&#39;s insert a post with the same title but use a query to update the body column in case of conflicts: # In Postgres (it requires the conflict target for updates): on_conflict = [set: [body: &quot;updated&quot;]] {:ok, updated} = MyRepo.insert(%Post{title: &quot;this is unique&quot;}, on_conflict: on_conflict, conflict_target: :title) # In MySQL (conflict target is not supported): on_conflict = [set: [title: &quot;updated&quot;]] {:ok, updated} = MyRepo.insert(%Post{id: inserted.id, title: &quot;updated&quot;}, on_conflict: on_conflict) In the examples above, even though it returned :ok, we do not know if we inserted new data or if we updated only the :on_conflict fields. In case an update happened, the data in the struct most likely does not match the data in the database. For example, autogenerated fields such as inserted_at will point to now rather than the time the struct was actually inserted. If you need to guarantee the data in the returned struct mirrors the database, you have three options: Use on_conflict: :replace_all, although that will replace all fields in the database with the ones in the struct/changeset, including autogenerated fields such as insert_at and updated_at: MyRepo.insert(%Post{title: &quot;this is unique&quot;}, on_conflict: :replace_all, conflict_target: :title) Specify read_after_writes: true in your schema for choosing fields that are read from the database after every operation. Or pass returning: true to insert to read all fields back: MyRepo.insert(%Post{title: &quot;this is unique&quot;}, returning: true, on_conflict: on_conflict, conflict_target: :title) Alternatively, read the data again from the database in a separate query. This option requires the primary key to be generated by the database: {:ok, updated} = MyRepo.insert(%Post{title: &quot;this is unique&quot;}, on_conflict: on_conflict) Repo.get(Post, updated.id) Because of the inability to know if the struct is up to date or not, inserting a struct with associations and using the :on_conflict option at the same time is not recommended, as Ecto will be unable to actually track the proper status of the association. Callback implementation for Ecto.Repo.insert/2."},{"ref":"Banking.Repo.html#insert!/2","title":"Banking.Repo.insert!/2","type":"function","doc":"Same as c:insert/2 but returns the struct or raises if the changeset is invalid. Callback implementation for Ecto.Repo.insert!/2."},{"ref":"Banking.Repo.html#insert_all/3","title":"Banking.Repo.insert_all/3","type":"function","doc":"Inserts all entries into the repository. It expects a schema module (MyApp.User) or a source (&quot;users&quot;) or both ({&quot;users&quot;, MyApp.User}) as the first argument. The second argument is a list of entries to be inserted, either as keyword lists or as maps. The keys of the entries are the field names as atoms and the value should be the respective value for the field type or, optionally, an Ecto.Query that returns a single entry with a single value. It returns a tuple containing the number of entries and any returned result as second element. If the database does not support RETURNING in INSERT statements or no return result was selected, the second element will be nil. When a schema module is given, the entries given will be properly dumped before being sent to the database. If the schema contains an autogenerated ID field, it will be handled either at the adapter or the storage layer. However any other autogenerated value, like timestamps, won&#39;t be autogenerated when using c:insert_all/3. This is by design as this function aims to be a more direct way to insert data into the database without the conveniences of c:insert/2. This is also consistent with c:update_all/3 that does not handle timestamps as well. It is also not possible to use insert_all to insert across multiple tables, therefore associations are not supported. If a source is given, without a schema module, the given fields are passed as is to the adapter. Options :returning - selects which fields to return. When true, returns all fields in the given schema. May be a list of fields, where a struct is still returned but only with the given fields. Or false, where nothing is returned (the default). This option is not supported by all databases. :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any @schema_prefix set in the schema. :on_conflict - It may be one of :raise (the default), :nothing, :replace_all, :replace_all_except_primary_key, {:replace, fields}, a keyword list of update instructions or an Ecto.Query query for updates. See the &quot;Upserts&quot; section for more information. :conflict_target - A list of column names to verify for conflicts. It is expected those columns to have unique indexes on them that may conflict. If none is specified, the conflict target is left up to the database. It may also be {:constraint, constraint_name_as_atom} in databases that support the &quot;ON CONSTRAINT&quot; expression, such as PostgreSQL, or {:unsafe_fragment, binary_fragment} to pass any expression to the database without any sanitization, such as ON CONFLICT (coalesce(firstname, &quot;&quot;), coalesce(lastname, &quot;&quot;)). See the &quot;Shared options&quot; section at the module documentation for remaining options. Examples MyRepo.insert_all(Post, [[title: &quot;My first post&quot;], [title: &quot;My second post&quot;]]) MyRepo.insert_all(Post, [%{title: &quot;My first post&quot;}, %{title: &quot;My second post&quot;}]) Upserts c:insert_all/3 provides upserts (update or inserts) via the :on_conflict option. The :on_conflict option supports the following values: :raise - raises if there is a conflicting primary key or unique index :nothing - ignores the error in case of conflicts :replace_all - replace all values on the existing row by the new entry, including values not sent explicitly by Ecto, such as database defaults. This option requires a schema :replace_all_except_primary_key - same as above except primary keys are not replaced. This option requires a schema {:replace, fields} - replace only specific columns. This option requires conflict_target a keyword list of update instructions - such as the one given to c:update_all/3, for example: [set: [title: &quot;new title&quot;]] an Ecto.Query that will act as an UPDATE statement, such as the one given to c:update_all/3 Upserts map to &quot;ON CONFLICT&quot; on databases like Postgres and &quot;ON DUPLICATE KEY&quot; on databases such as MySQL. Return values By default, both Postgres and MySQL return the amount of entries inserted on c:insert_all/3. However, when the :on_conflict option is specified, Postgres will only return a row if it was affected while MySQL returns at least the number of entries attempted. For example, if :on_conflict is set to :nothing, Postgres will return 0 if no new entry was added while MySQL will still return the amount of entries attempted to be inserted, even if no entry was added. Even worse, if :on_conflict is query, MySQL will return the number of attempted entries plus the number of entries modified by the UPDATE query. Callback implementation for Ecto.Repo.insert_all/3."},{"ref":"Banking.Repo.html#insert_or_update/2","title":"Banking.Repo.insert_or_update/2","type":"function","doc":"Inserts or updates a changeset depending on whether the struct is persisted or not. The distinction whether to insert or update will be made on the Ecto.Schema.Metadata field :state. The :state is automatically set by Ecto when loading or building a schema. Please note that for this to work, you will have to load existing structs from the database. So even if the struct exists, this won&#39;t work: struct = %Post{id: &quot;existing_id&quot;, ...} MyRepo.insert_or_update changeset # =&gt; {:error, changeset} # id already exists Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any @schema_prefix set any schemas. Also, the @schema_prefix for the parent record will override all default @schema_prefixs set in any child schemas for associations. :stale_error_field - The field where stale errors will be added in the returning changeset. This option can be used to avoid raising Ecto.StaleEntryError. Only applies to updates. :stale_error_message - The message to add to the configured :stale_error_field when stale errors happen, defaults to &quot;is stale&quot;. Only applies to updates. See the &quot;Shared options&quot; section at the module documentation for more options. Example result = case MyRepo.get(Post, id) do nil -&gt; %Post{id: id} # Post not found, we build one post -&gt; post # Post exists, let&#39;s use it end |&gt; Post.changeset(changes) |&gt; MyRepo.insert_or_update case result do {:ok, struct} -&gt; # Inserted or updated with success {:error, changeset} -&gt; # Something went wrong end Callback implementation for Ecto.Repo.insert_or_update/2."},{"ref":"Banking.Repo.html#insert_or_update!/2","title":"Banking.Repo.insert_or_update!/2","type":"function","doc":"Same as c:insert_or_update/2 but returns the struct or raises if the changeset is invalid. Callback implementation for Ecto.Repo.insert_or_update!/2."},{"ref":"Banking.Repo.html#load/2","title":"Banking.Repo.load/2","type":"function","doc":"Loads data into a struct or a map. The first argument can be a a schema module, or a map (of types) and determines the return value: a struct or a map, respectively. The second argument data specifies fields and values that are to be loaded. It can be a map, a keyword list, or a {fields, values} tuple. Fields can be atoms or strings. Fields that are not present in the schema (or types map) are ignored. If any of the values has invalid type, an error is raised. Examples iex&gt; MyRepo.load(User, %{name: &quot;Alice&quot;, age: 25}) %User{name: &quot;Alice&quot;, age: 25} iex&gt; MyRepo.load(User, [name: &quot;Alice&quot;, age: 25]) %User{name: &quot;Alice&quot;, age: 25} data can also take form of {fields, values}: iex&gt; MyRepo.load(User, {[:name, :age], [&quot;Alice&quot;, 25]}) %User{name: &quot;Alice&quot;, age: 25, ...} The first argument can also be a types map: iex&gt; types = %{name: :string, age: :integer} iex&gt; MyRepo.load(types, %{name: &quot;Alice&quot;, age: 25}) %{name: &quot;Alice&quot;, age: 25} This function is especially useful when parsing raw query results: iex&gt; result = Ecto.Adapters.SQL.query!(MyRepo, &quot;SELECT * FROM users&quot;, []) iex&gt; Enum.map(result.rows, &amp;MyRepo.load(User, {result.columns, &amp;1})) [%User{...}, ...] Callback implementation for Ecto.Repo.load/2."},{"ref":"Banking.Repo.html#one/2","title":"Banking.Repo.one/2","type":"function","doc":"Fetches a single result from the query. Returns nil if no result was found. Raises if more than one entry. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. See the &quot;Shared options&quot; section at the module documentation for more options. Examples Repo.one(Post) Repo.one(from p in Post, where: p.like_count &gt; 10) query = from p in Post, where: p.like_count &gt; 10 Repo.one(query, prefix: &quot;private&quot;) Callback implementation for Ecto.Repo.one/2."},{"ref":"Banking.Repo.html#one!/2","title":"Banking.Repo.one!/2","type":"function","doc":"Similar to c:one/2 but raises Ecto.NoResultsError if no record was found. Raises if more than one entry. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. See the &quot;Shared options&quot; section at the module documentation for more options. Callback implementation for Ecto.Repo.one!/2."},{"ref":"Banking.Repo.html#preload/3","title":"Banking.Repo.preload/3","type":"function","doc":"Preloads all associations on the given struct or structs. This is similar to Ecto.Query.preload/3 except it allows you to preload structs after they have been fetched from the database. In case the association was already loaded, preload won&#39;t attempt to reload it. Options :force - By default, Ecto won&#39;t preload associations that are already loaded. By setting this option to true, any existing association will be discarded and reloaded. :in_parallel - If the preloads must be done in parallel. It can only be performed when we have more than one preload and the repository is not in a transaction. Defaults to true. :prefix - the prefix to fetch preloads from. By default, queries will use the same prefix as the one in the given collection. This option allows the prefix to be changed. See the &quot;Shared options&quot; section at the module documentation for more options. Examples # Use a single atom to preload an association posts = Repo.preload posts, :comments # Use a list of atoms to preload multiple associations posts = Repo.preload posts, [:comments, :authors] # Use a keyword list to preload nested associations as well posts = Repo.preload posts, [comments: [:replies, :likes], authors: []] # Use a keyword list to customize how associations are queried posts = Repo.preload posts, [comments: from(c in Comment, order_by: c.published_at)] # Use a two-element tuple for a custom query and nested association definition query = from c in Comment, order_by: c.published_at posts = Repo.preload posts, [comments: {query, [:replies, :likes]}] The query given to preload may also preload its own associations. Callback implementation for Ecto.Repo.preload/3."},{"ref":"Banking.Repo.html#prepare_query/3","title":"Banking.Repo.prepare_query/3","type":"function","doc":"A user customizable callback invoked for query-based operations. This callback can be used to further modify the query and options before it is transformed and sent to the database. This callback is invoked for all query APIs, including the stream function, but it is not invoked for insert_all nor any of the schema functions. Callback implementation for Ecto.Repo.prepare_query/3."},{"ref":"Banking.Repo.html#put_dynamic_repo/1","title":"Banking.Repo.put_dynamic_repo/1","type":"function","doc":"Sets the dynamic repository to be used in further interactions. Sometimes you may want a single Ecto repository to talk to many different database instances. By default, when you call MyApp.Repo.start_link/1, it will start a repository with name MyApp.Repo. But if you want to start multiple repositories, you can give each of them a different name: MyApp.Repo.start_link(name: :tenant_foo, hostname: &quot;foo.example.com&quot;) MyApp.Repo.start_link(name: :tenant_bar, hostname: &quot;bar.example.com&quot;) You can also start repositories without names by explicitly setting the name to nil: MyApp.Repo.start_link(name: nil, hostname: &quot;temp.example.com&quot;) However, once the repository is started, you can&#39;t directly interact with it, since all operations in MyApp.Repo are sent by default to the repository named MyApp.Repo. You can change the default repo at compile time with: use Ecto.Repo, default_dynamic_repo: :name_of_repo Or you can change it anytime at runtime by calling put_dynamic_repo/1: MyApp.Repo.put_dynamic_repo(:tenant_foo) From this moment on, all future queries done by the current process will run on :tenant_foo. Note this feature is experimental and may be changed or removed in future releases. Callback implementation for Ecto.Repo.put_dynamic_repo/1."},{"ref":"Banking.Repo.html#query/3","title":"Banking.Repo.query/3","type":"function","doc":"A convenience function for SQL-based repositories that executes the given query. See Ecto.Adapters.SQL.query/4 for more information."},{"ref":"Banking.Repo.html#query!/3","title":"Banking.Repo.query!/3","type":"function","doc":"A convenience function for SQL-based repositories that executes the given query. See Ecto.Adapters.SQL.query!/4 for more information."},{"ref":"Banking.Repo.html#rollback/1","title":"Banking.Repo.rollback/1","type":"function","doc":"Rolls back the current transaction. The transaction will return the value given as {:error, value}. Callback implementation for Ecto.Repo.rollback/1."},{"ref":"Banking.Repo.html#start_link/1","title":"Banking.Repo.start_link/1","type":"function","doc":"Starts any connection pooling or supervision and return {:ok, pid} or just :ok if nothing needs to be done. Returns {:error, {:already_started, pid}} if the repo is already started or {:error, term} in case anything else goes wrong. Options See the configuration in the moduledoc for options shared between adapters, for adapter-specific configuration see the adapter&#39;s documentation. Callback implementation for Ecto.Repo.start_link/1."},{"ref":"Banking.Repo.html#stop/1","title":"Banking.Repo.stop/1","type":"function","doc":"Shuts down the repository. Callback implementation for Ecto.Repo.stop/1."},{"ref":"Banking.Repo.html#stream/2","title":"Banking.Repo.stream/2","type":"function","doc":"Returns a lazy enumerable that emits all entries from the data store matching the given query. SQL adapters, such as Postgres and MySQL, can only enumerate a stream inside a transaction. May raise Ecto.QueryError if query validation fails. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This will be applied to all from and joins in the query that did not have a prefix previously given either via the :prefix option on join/from or via @schema_prefix in the schema. For more information see the &quot;Query Prefix&quot; section of the Ecto.Query documentation. :max_rows - The number of rows to load from the database as we stream. It is supported at least by Postgres and MySQL and defaults to 500. See the &quot;Shared options&quot; section at the module documentation for more options. Example # Fetch all post titles query = from p in Post, select: p.title stream = MyRepo.stream(query) MyRepo.transaction(fn() -&gt; Enum.to_list(stream) end) Callback implementation for Ecto.Repo.stream/2."},{"ref":"Banking.Repo.html#to_sql/2","title":"Banking.Repo.to_sql/2","type":"function","doc":"A convenience function for SQL-based repositories that translates the given query to SQL. See Ecto.Adapters.SQL.to_sql/3 for more information."},{"ref":"Banking.Repo.html#transaction/2","title":"Banking.Repo.transaction/2","type":"function","doc":"Runs the given function or Ecto.Multi inside a transaction. Use with function c:transaction/2 can be called with both a function of arity zero or one. The arity zero function will just be executed as is, while the arity one function will receive the repo of the transaction as its first argument, similar to Ecto.Multi.run. If an unhandled error occurs the transaction will be rolled back and the error will bubble up from the transaction function. If no error occurred the transaction will be committed when the function returns. A transaction can be explicitly rolled back by calling c:rollback/1, this will immediately leave the function and return the value given to rollback as {:error, value}. A successful transaction returns the value returned by the function wrapped in a tuple as {:ok, value}. If c:transaction/2 is called inside another transaction, the function is simply executed, without wrapping the new transaction call in any way. If there is an error in the inner transaction and the error is rescued, or the inner transaction is rolled back, the whole outer transaction is marked as tainted, guaranteeing nothing will be committed. Use with Ecto.Multi Besides functions transaction can be used with an Ecto.Multi struct. Transaction will be started, all operations applied and in case of success committed returning {:ok, changes}. In case of any errors the transaction will be rolled back and {:error, failed_operation, failed_value, changes_so_far} will be returned. You can read more about using transactions with Ecto.Multi as well as see some examples in the Ecto.Multi documentation. Options See the &quot;Shared options&quot; section at the module documentation for more options. Examples import Ecto.Changeset, only: [change: 2] MyRepo.transaction(fn -&gt; MyRepo.update!(change(alice, balance: alice.balance - 10)) MyRepo.update!(change(bob, balance: bob.balance + 10)) end) # When passing a function of arity 1, it receives the repository itself MyRepo.transaction(fn repo -&gt; repo.insert!(%Post{}) end) # Roll back a transaction explicitly MyRepo.transaction(fn -&gt; p = MyRepo.insert!(%Post{}) if not Editor.post_allowed?(p) do MyRepo.rollback(:posting_not_allowed) end end) # With Ecto.Multi Ecto.Multi.new |&gt; Ecto.Multi.insert(:post, %Post{}) |&gt; MyRepo.transaction Callback implementation for Ecto.Repo.transaction/2."},{"ref":"Banking.Repo.html#update/2","title":"Banking.Repo.update/2","type":"function","doc":"Updates a changeset using its primary key. A changeset is required as it is the only mechanism for tracking dirty changes. Only the fields present in the changes part of the changeset are sent to the database. Any other, in-memory changes done to the schema are ignored. If the struct has no primary key, Ecto.NoPrimaryKeyFieldError will be raised. If the struct cannot be found, Ecto.StaleEntryError will be raised. It returns {:ok, struct} if the struct has been successfully updated or {:error, changeset} if there was a validation or a known constraint error. Options :returning - selects which fields to return. It accepts a list of fields to be returned from the database. When true, returns all fields. When false, no extra fields are returned. It will always include all fields in read_after_writes. Not all databases support this option. :force - By default, if there are no changes in the changeset, c:update/2 is a no-op. By setting this option to true, update callbacks will always be executed, even if there are no changes (including timestamps). :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any @schema_prefix set any schemas. Also, the @schema_prefix for the parent record will override all default @schema_prefixs set in any child schemas for associations. :stale_error_field - The field where stale errors will be added in the returning changeset. This option can be used to avoid raising Ecto.StaleEntryError. :stale_error_message - The message to add to the configured :stale_error_field when stale errors happen, defaults to &quot;is stale&quot;. See the &quot;Shared options&quot; section at the module documentation for more options. Example post = MyRepo.get!(Post, 42) post = Ecto.Changeset.change post, title: &quot;New title&quot; case MyRepo.update post do {:ok, struct} -&gt; # Updated with success {:error, changeset} -&gt; # Something went wrong end Callback implementation for Ecto.Repo.update/2."},{"ref":"Banking.Repo.html#update!/2","title":"Banking.Repo.update!/2","type":"function","doc":"Same as c:update/2 but returns the struct or raises if the changeset is invalid. Callback implementation for Ecto.Repo.update!/2."},{"ref":"Banking.Repo.html#update_all/3","title":"Banking.Repo.update_all/3","type":"function","doc":"Updates all entries matching the given query with the given values. It returns a tuple containing the number of entries and any returned result as second element. The second element is nil by default unless a select is supplied in the update query. Note, however, not all databases support returning data from UPDATEs. Keep in mind this update_all will not update autogenerated fields like the updated_at columns. See Ecto.Query.update/3 for update operations that can be performed on fields. Options :prefix - The prefix to run the query on (such as the schema path in Postgres or the database in MySQL). This overrides the prefix set in the query and any @schema_prefix set in the schema. See the &quot;Shared options&quot; section at the module documentation for remaining options. Examples MyRepo.update_all(Post, set: [title: &quot;New title&quot;]) MyRepo.update_all(Post, inc: [visits: 1]) from(p in Post, where: p.id &lt; 10, select: p.visits) |&gt; MyRepo.update_all(set: [title: &quot;New title&quot;]) from(p in Post, where: p.id &lt; 10, update: [set: [title: &quot;New title&quot;]]) |&gt; MyRepo.update_all([]) from(p in Post, where: p.id &lt; 10, update: [set: [title: ^new_title]]) |&gt; MyRepo.update_all([]) from(p in Post, where: p.id &lt; 10, update: [set: [title: fragment(&quot;upper(?)&quot;, ^new_title)]]) |&gt; MyRepo.update_all([]) Callback implementation for Ecto.Repo.update_all/3."},{"ref":"Banking.Session.html","title":"Banking.Session","type":"module","doc":""},{"ref":"Banking.Session.html#create/3","title":"Banking.Session.create/3","type":"function","doc":""},{"ref":"Banking.Session.html#create_jwt/3","title":"Banking.Session.create_jwt/3","type":"function","doc":""},{"ref":"Banking.Session.html#get/1","title":"Banking.Session.get/1","type":"function","doc":""},{"ref":"Banking.Session.html#to_jwt/1","title":"Banking.Session.to_jwt/1","type":"function","doc":""},{"ref":"Banking.Session.Guardian.Plug.html","title":"Banking.Session.Guardian.Plug","type":"module","doc":""},{"ref":"Banking.Session.Guardian.Plug.html#authenticated?/2","title":"Banking.Session.Guardian.Plug.authenticated?/2","type":"function","doc":""},{"ref":"Banking.Session.Guardian.Plug.html#clear_remember_me/2","title":"Banking.Session.Guardian.Plug.clear_remember_me/2","type":"function","doc":""},{"ref":"Banking.Session.Guardian.Plug.html#current_claims/2","title":"Banking.Session.Guardian.Plug.current_claims/2","type":"function","doc":""},{"ref":"Banking.Session.Guardian.Plug.html#current_resource/2","title":"Banking.Session.Guardian.Plug.current_resource/2","type":"function","doc":""},{"ref":"Banking.Session.Guardian.Plug.html#current_token/2","title":"Banking.Session.Guardian.Plug.current_token/2","type":"function","doc":""},{"ref":"Banking.Session.Guardian.Plug.html#implementation/0","title":"Banking.Session.Guardian.Plug.implementation/0","type":"function","doc":""},{"ref":"Banking.Session.Guardian.Plug.html#put_current_claims/3","title":"Banking.Session.Guardian.Plug.put_current_claims/3","type":"function","doc":""},{"ref":"Banking.Session.Guardian.Plug.html#put_current_resource/3","title":"Banking.Session.Guardian.Plug.put_current_resource/3","type":"function","doc":""},{"ref":"Banking.Session.Guardian.Plug.html#put_current_token/3","title":"Banking.Session.Guardian.Plug.put_current_token/3","type":"function","doc":""},{"ref":"Banking.Session.Guardian.Plug.html#put_session_token/3","title":"Banking.Session.Guardian.Plug.put_session_token/3","type":"function","doc":""},{"ref":"Banking.Session.Guardian.Plug.html#remember_me/4","title":"Banking.Session.Guardian.Plug.remember_me/4","type":"function","doc":""},{"ref":"Banking.Session.Guardian.Plug.html#remember_me_from_token/4","title":"Banking.Session.Guardian.Plug.remember_me_from_token/4","type":"function","doc":""},{"ref":"Banking.Session.Guardian.Plug.html#sign_in/4","title":"Banking.Session.Guardian.Plug.sign_in/4","type":"function","doc":""},{"ref":"Banking.Session.Guardian.Plug.html#sign_out/2","title":"Banking.Session.Guardian.Plug.sign_out/2","type":"function","doc":""},{"ref":"BankingWeb.html","title":"BankingWeb","type":"module","doc":"The entrypoint for defining your web interface, such as controllers, views, channels and so on. This can be used in your application as: use BankingWeb, :controller use BankingWeb, :view The definitions below will be executed for every view, controller, etc, so keep them short and clean, focused on imports, uses and aliases. Do NOT define functions inside the quoted expressions below. Instead, define any helper function in modules and import those modules here."},{"ref":"BankingWeb.html#__using__/1","title":"BankingWeb.__using__/1","type":"macro","doc":"When used, dispatch to the appropriate controller/view/etc."},{"ref":"BankingWeb.html#channel/0","title":"BankingWeb.channel/0","type":"function","doc":""},{"ref":"BankingWeb.html#controller/0","title":"BankingWeb.controller/0","type":"function","doc":""},{"ref":"BankingWeb.html#router/0","title":"BankingWeb.router/0","type":"function","doc":""},{"ref":"BankingWeb.html#view/0","title":"BankingWeb.view/0","type":"function","doc":""},{"ref":"BankingWeb.Endpoint.html","title":"BankingWeb.Endpoint","type":"module","doc":""},{"ref":"BankingWeb.Endpoint.html#broadcast/3","title":"BankingWeb.Endpoint.broadcast/3","type":"function","doc":"Broadcasts a msg as event in the given topic. Callback implementation for Phoenix.Endpoint.broadcast/3."},{"ref":"BankingWeb.Endpoint.html#broadcast!/3","title":"BankingWeb.Endpoint.broadcast!/3","type":"function","doc":"Broadcasts a msg as event in the given topic. Raises in case of failures. Callback implementation for Phoenix.Endpoint.broadcast!/3."},{"ref":"BankingWeb.Endpoint.html#broadcast_from/4","title":"BankingWeb.Endpoint.broadcast_from/4","type":"function","doc":"Broadcasts a msg from the given from as event in the given topic. Callback implementation for Phoenix.Endpoint.broadcast_from/4."},{"ref":"BankingWeb.Endpoint.html#broadcast_from!/4","title":"BankingWeb.Endpoint.broadcast_from!/4","type":"function","doc":"Broadcasts a msg from the given from as event in the given topic. Raises in case of failures. Callback implementation for Phoenix.Endpoint.broadcast_from!/4."},{"ref":"BankingWeb.Endpoint.html#call/2","title":"BankingWeb.Endpoint.call/2","type":"function","doc":"Callback implementation for Plug.call/2."},{"ref":"BankingWeb.Endpoint.html#child_spec/1","title":"BankingWeb.Endpoint.child_spec/1","type":"function","doc":"Returns the child specification to start the endpoint under a supervision tree."},{"ref":"BankingWeb.Endpoint.html#config/2","title":"BankingWeb.Endpoint.config/2","type":"function","doc":"Returns the endpoint configuration for key Returns default if the key does not exist."},{"ref":"BankingWeb.Endpoint.html#config_change/2","title":"BankingWeb.Endpoint.config_change/2","type":"function","doc":"Reloads the configuration given the application environment changes."},{"ref":"BankingWeb.Endpoint.html#host/0","title":"BankingWeb.Endpoint.host/0","type":"function","doc":"Returns the host for the given endpoint."},{"ref":"BankingWeb.Endpoint.html#init/1","title":"BankingWeb.Endpoint.init/1","type":"function","doc":"Callback implementation for Plug.init/1."},{"ref":"BankingWeb.Endpoint.html#instrument/3","title":"BankingWeb.Endpoint.instrument/3","type":"macro","doc":"Instruments the given function. event is the event identifier (usually an atom) that specifies which instrumenting function to call in the instrumenter modules. runtime is metadata to be associated with the event at runtime (e.g., the query being issued if the event to instrument is a DB query). Examples instrument :render_view, %{view: &quot;index.html&quot;}, fn -&gt; render(conn, &quot;index.html&quot;) end"},{"ref":"BankingWeb.Endpoint.html#path/1","title":"BankingWeb.Endpoint.path/1","type":"function","doc":"Generates the path information when routing to this endpoint."},{"ref":"BankingWeb.Endpoint.html#script_name/0","title":"BankingWeb.Endpoint.script_name/0","type":"function","doc":"Generates the script name."},{"ref":"BankingWeb.Endpoint.html#start_link/1","title":"BankingWeb.Endpoint.start_link/1","type":"function","doc":"Starts the endpoint supervision tree."},{"ref":"BankingWeb.Endpoint.html#static_integrity/1","title":"BankingWeb.Endpoint.static_integrity/1","type":"function","doc":"Generates a base64-encoded cryptographic hash (sha512) to a static file in priv/static. Meant to be used for Subresource Integrity with CDNs."},{"ref":"BankingWeb.Endpoint.html#static_lookup/1","title":"BankingWeb.Endpoint.static_lookup/1","type":"function","doc":"Returns a two item tuple with the first item being the static_path and the second item being the static_integrity."},{"ref":"BankingWeb.Endpoint.html#static_path/1","title":"BankingWeb.Endpoint.static_path/1","type":"function","doc":"Generates a route to a static file in priv/static."},{"ref":"BankingWeb.Endpoint.html#static_url/0","title":"BankingWeb.Endpoint.static_url/0","type":"function","doc":"Generates the static URL without any path information. It uses the configuration under :static_url to generate such. It falls back to :url if :static_url is not set."},{"ref":"BankingWeb.Endpoint.html#struct_url/0","title":"BankingWeb.Endpoint.struct_url/0","type":"function","doc":"Generates the endpoint base URL but as a URI struct. It uses the configuration under :url to generate such. Useful for manipulating the URL data and passing it to URL helpers."},{"ref":"BankingWeb.Endpoint.html#subscribe/1","title":"BankingWeb.Endpoint.subscribe/1","type":"function","doc":""},{"ref":"BankingWeb.Endpoint.html#subscribe/3","title":"BankingWeb.Endpoint.subscribe/3","type":"function","doc":""},{"ref":"BankingWeb.Endpoint.html#unsubscribe/1","title":"BankingWeb.Endpoint.unsubscribe/1","type":"function","doc":"Unsubscribes the caller from the given topic. Callback implementation for Phoenix.Endpoint.unsubscribe/1."},{"ref":"BankingWeb.Endpoint.html#url/0","title":"BankingWeb.Endpoint.url/0","type":"function","doc":"Generates the endpoint base URL without any path information. It uses the configuration under :url to generate such."},{"ref":"BankingWeb.ErrorHelpers.html","title":"BankingWeb.ErrorHelpers","type":"module","doc":"Conveniences for translating and building error messages."},{"ref":"BankingWeb.ErrorHelpers.html#error_tag/2","title":"BankingWeb.ErrorHelpers.error_tag/2","type":"function","doc":"Generates tag for inlined form input errors."},{"ref":"BankingWeb.ErrorHelpers.html#translate_error/1","title":"BankingWeb.ErrorHelpers.translate_error/1","type":"function","doc":"Translates an error message using gettext."},{"ref":"BankingWeb.ErrorView.html","title":"BankingWeb.ErrorView","type":"module","doc":""},{"ref":"BankingWeb.ErrorView.html#__phoenix_recompile__?/0","title":"BankingWeb.ErrorView.__phoenix_recompile__?/0","type":"function","doc":"Returns true whenever the list of templates changes in the filesystem."},{"ref":"BankingWeb.ErrorView.html#__resource__/0","title":"BankingWeb.ErrorView.__resource__/0","type":"function","doc":"The resource name, as an atom, for this view"},{"ref":"BankingWeb.ErrorView.html#__templates__/0","title":"BankingWeb.ErrorView.__templates__/0","type":"function","doc":"Returns the template root alongside all templates."},{"ref":"BankingWeb.ErrorView.html#render/2","title":"BankingWeb.ErrorView.render/2","type":"function","doc":"Renders the given template locally."},{"ref":"BankingWeb.ErrorView.html#template_not_found/2","title":"BankingWeb.ErrorView.template_not_found/2","type":"function","doc":"Callback invoked when no template is found. By default it raises but can be customized to render a particular template."},{"ref":"BankingWeb.Gettext.html","title":"BankingWeb.Gettext","type":"module","doc":"A module providing Internationalization with a gettext-based API. By using Gettext, your module gains a set of macros for translations, for example: import BankingWeb.Gettext # Simple translation gettext(&quot;Here is the string to translate&quot;) # Plural translation ngettext(&quot;Here is the string to translate&quot;, &quot;Here are the strings to translate&quot;, 3) # Domain-based translation dgettext(&quot;errors&quot;, &quot;Here is the error message to translate&quot;) See the Gettext Docs for detailed usage."},{"ref":"BankingWeb.Gettext.html#dgettext/3","title":"BankingWeb.Gettext.dgettext/3","type":"macro","doc":""},{"ref":"BankingWeb.Gettext.html#dgettext_noop/2","title":"BankingWeb.Gettext.dgettext_noop/2","type":"macro","doc":""},{"ref":"BankingWeb.Gettext.html#dngettext/5","title":"BankingWeb.Gettext.dngettext/5","type":"macro","doc":""},{"ref":"BankingWeb.Gettext.html#dngettext_noop/3","title":"BankingWeb.Gettext.dngettext_noop/3","type":"macro","doc":""},{"ref":"BankingWeb.Gettext.html#gettext/2","title":"BankingWeb.Gettext.gettext/2","type":"macro","doc":""},{"ref":"BankingWeb.Gettext.html#gettext_comment/1","title":"BankingWeb.Gettext.gettext_comment/1","type":"macro","doc":""},{"ref":"BankingWeb.Gettext.html#gettext_noop/1","title":"BankingWeb.Gettext.gettext_noop/1","type":"macro","doc":""},{"ref":"BankingWeb.Gettext.html#handle_missing_bindings/2","title":"BankingWeb.Gettext.handle_missing_bindings/2","type":"function","doc":"Default handling for missing bindings. This function is called when there are missing bindings in a translation. It takes a Gettext.MissingBindingsError struct and the translation with the wrong bindings left as is with the %{} syntax. For example, if something like this is called: MyApp.Gettext.gettext(&quot;Hello %{name}, welcome to %{country}&quot;, name: &quot;Jane&quot;, country: &quot;Italy&quot;) and our it/LC_MESSAGES/default.po looks like this: msgid &quot;Hello %{name}, welcome to %{country}&quot; msgstr &quot;Ciao %{name}, benvenuto in %{cowntry}&quot; # (typo) then Gettext will call: MyApp.Gettext.handle_missing_bindings(exception, &quot;Ciao Jane, benvenuto in %{cowntry}&quot;) where exception is a struct that looks like this: %Gettext.MissingBindingsError{ backend: MyApp.Gettext, domain: &quot;default&quot;, locale: &quot;it&quot;, msgid: &quot;Hello %{name}, welcome to %{country}&quot;, bindings: [:country], } The return value of the c:handle_missing_bindings/2 callback is used as the translated string that the translation macros and functions return. The default implementation for this function uses Logger.error/1 to warn about the missing binding and returns the translated message with the incomplete bindings. This function can be overridden. For example, to raise when there are missing bindings: def handle_missing_bindings(exception, _incomplete) do raise exception end Callback implementation for Gettext.Backend.handle_missing_bindings/2."},{"ref":"BankingWeb.Gettext.html#handle_missing_plural_translation/6","title":"BankingWeb.Gettext.handle_missing_plural_translation/6","type":"function","doc":"Default handling for plural translations with a missing translation. Same as c:handle_missing_translation/4, but for plural translations. In this case, n is the number used for pluralizing the translated string. Callback implementation for Gettext.Backend.handle_missing_plural_translation/6."},{"ref":"BankingWeb.Gettext.html#handle_missing_translation/4","title":"BankingWeb.Gettext.handle_missing_translation/4","type":"function","doc":"Default handling for translations with a missing translation. When a Gettext function/macro is called with a string to translate into a locale but that locale doesn&#39;t provide a translation for that string, this callback is invoked. msgid is the string that Gettext tried to translate. This function should return {:ok, translated} if a translation can be fetched or constructed for the given string, or {:default, msgid} otherwise. Callback implementation for Gettext.Backend.handle_missing_translation/4."},{"ref":"BankingWeb.Gettext.html#lgettext/4","title":"BankingWeb.Gettext.lgettext/4","type":"function","doc":""},{"ref":"BankingWeb.Gettext.html#lngettext/6","title":"BankingWeb.Gettext.lngettext/6","type":"function","doc":""},{"ref":"BankingWeb.Gettext.html#ngettext/4","title":"BankingWeb.Gettext.ngettext/4","type":"macro","doc":""},{"ref":"BankingWeb.Gettext.html#ngettext_noop/2","title":"BankingWeb.Gettext.ngettext_noop/2","type":"macro","doc":""},{"ref":"BankingWeb.GraphQL.Plug.Pipeline.html","title":"BankingWeb.GraphQL.Plug.Pipeline","type":"module","doc":""},{"ref":"BankingWeb.GraphQL.Plug.Pipeline.html#call/2","title":"BankingWeb.GraphQL.Plug.Pipeline.call/2","type":"function","doc":"Callback implementation for Plug.call/2."},{"ref":"BankingWeb.GraphQL.Plug.Pipeline.html#init/1","title":"BankingWeb.GraphQL.Plug.Pipeline.init/1","type":"function","doc":"Callback implementation for Plug.init/1."},{"ref":"BankingWeb.GraphQL.Plugs.Context.html","title":"BankingWeb.GraphQL.Plugs.Context","type":"module","doc":""},{"ref":"BankingWeb.GraphQL.Plugs.Context.html#build_context/1","title":"BankingWeb.GraphQL.Plugs.Context.build_context/1","type":"function","doc":""},{"ref":"BankingWeb.GraphQL.Plugs.Context.html#call/2","title":"BankingWeb.GraphQL.Plugs.Context.call/2","type":"function","doc":"Callback implementation for Plug.call/2."},{"ref":"BankingWeb.GraphQL.Plugs.Context.html#init/1","title":"BankingWeb.GraphQL.Plugs.Context.init/1","type":"function","doc":"Callback implementation for Plug.init/1."},{"ref":"BankingWeb.LayoutView.html","title":"BankingWeb.LayoutView","type":"module","doc":""},{"ref":"BankingWeb.LayoutView.html#__phoenix_recompile__?/0","title":"BankingWeb.LayoutView.__phoenix_recompile__?/0","type":"function","doc":"Returns true whenever the list of templates changes in the filesystem."},{"ref":"BankingWeb.LayoutView.html#__resource__/0","title":"BankingWeb.LayoutView.__resource__/0","type":"function","doc":"The resource name, as an atom, for this view"},{"ref":"BankingWeb.LayoutView.html#__templates__/0","title":"BankingWeb.LayoutView.__templates__/0","type":"function","doc":"Returns the template root alongside all templates."},{"ref":"BankingWeb.LayoutView.html#render/2","title":"BankingWeb.LayoutView.render/2","type":"function","doc":"Renders the given template locally."},{"ref":"BankingWeb.LayoutView.html#template_not_found/2","title":"BankingWeb.LayoutView.template_not_found/2","type":"function","doc":"Callback invoked when no template is found. By default it raises but can be customized to render a particular template."},{"ref":"BankingWeb.PageController.html","title":"BankingWeb.PageController","type":"module","doc":""},{"ref":"BankingWeb.PageController.html#index/2","title":"BankingWeb.PageController.index/2","type":"function","doc":""},{"ref":"BankingWeb.PageView.html","title":"BankingWeb.PageView","type":"module","doc":""},{"ref":"BankingWeb.PageView.html#__phoenix_recompile__?/0","title":"BankingWeb.PageView.__phoenix_recompile__?/0","type":"function","doc":"Returns true whenever the list of templates changes in the filesystem."},{"ref":"BankingWeb.PageView.html#__resource__/0","title":"BankingWeb.PageView.__resource__/0","type":"function","doc":"The resource name, as an atom, for this view"},{"ref":"BankingWeb.PageView.html#__templates__/0","title":"BankingWeb.PageView.__templates__/0","type":"function","doc":"Returns the template root alongside all templates."},{"ref":"BankingWeb.PageView.html#render/2","title":"BankingWeb.PageView.render/2","type":"function","doc":"Renders the given template locally."},{"ref":"BankingWeb.PageView.html#template_not_found/2","title":"BankingWeb.PageView.template_not_found/2","type":"function","doc":"Callback invoked when no template is found. By default it raises but can be customized to render a particular template."},{"ref":"BankingWeb.Router.html","title":"BankingWeb.Router","type":"module","doc":""},{"ref":"BankingWeb.Router.html#api/2","title":"BankingWeb.Router.api/2","type":"function","doc":""},{"ref":"BankingWeb.Router.html#browser/2","title":"BankingWeb.Router.browser/2","type":"function","doc":""},{"ref":"BankingWeb.Router.html#call/2","title":"BankingWeb.Router.call/2","type":"function","doc":"Callback invoked by Plug on every request."},{"ref":"BankingWeb.Router.html#graphql/2","title":"BankingWeb.Router.graphql/2","type":"function","doc":""},{"ref":"BankingWeb.Router.html#init/1","title":"BankingWeb.Router.init/1","type":"function","doc":"Callback required by Plug that initializes the router for serving web requests."},{"ref":"BankingWeb.Router.Helpers.html","title":"BankingWeb.Router.Helpers","type":"module","doc":"Module with named helpers generated from BankingWeb.Router."},{"ref":"BankingWeb.Router.Helpers.html#page_path/2","title":"BankingWeb.Router.Helpers.page_path/2","type":"function","doc":""},{"ref":"BankingWeb.Router.Helpers.html#page_path/3","title":"BankingWeb.Router.Helpers.page_path/3","type":"function","doc":""},{"ref":"BankingWeb.Router.Helpers.html#page_url/2","title":"BankingWeb.Router.Helpers.page_url/2","type":"function","doc":""},{"ref":"BankingWeb.Router.Helpers.html#page_url/3","title":"BankingWeb.Router.Helpers.page_url/3","type":"function","doc":""},{"ref":"BankingWeb.Router.Helpers.html#path/2","title":"BankingWeb.Router.Helpers.path/2","type":"function","doc":"Generates the path information including any necessary prefix."},{"ref":"BankingWeb.Router.Helpers.html#static_integrity/2","title":"BankingWeb.Router.Helpers.static_integrity/2","type":"function","doc":"Generates an integrity hash to a static asset given its file path."},{"ref":"BankingWeb.Router.Helpers.html#static_path/2","title":"BankingWeb.Router.Helpers.static_path/2","type":"function","doc":"Generates path to a static asset given its file path."},{"ref":"BankingWeb.Router.Helpers.html#static_url/2","title":"BankingWeb.Router.Helpers.static_url/2","type":"function","doc":"Generates url to a static asset given its file path."},{"ref":"BankingWeb.Router.Helpers.html#url/1","title":"BankingWeb.Router.Helpers.url/1","type":"function","doc":"Generates the connection/endpoint base URL without any path information."},{"ref":"BankingWeb.UserSocket.html","title":"BankingWeb.UserSocket","type":"module","doc":""},{"ref":"BankingWeb.UserSocket.html#connect/3","title":"BankingWeb.UserSocket.connect/3","type":"function","doc":"Callback implementation for Phoenix.Socket.connect/3."},{"ref":"BankingWeb.UserSocket.html#id/1","title":"BankingWeb.UserSocket.id/1","type":"function","doc":"Identifies the socket connection. Socket IDs are topics that allow you to identify all sockets for a given user: def id(socket), do: &quot;users_socket:\#{socket.assigns.user_id}&quot; Would allow you to broadcast a &quot;disconnect&quot; event and terminate all active sockets and channels for a given user: MyApp.Endpoint.broadcast(&quot;users_socket:&quot; &lt;&gt; user.id, &quot;disconnect&quot;, %{}) Returning nil makes this socket anonymous. Callback implementation for Phoenix.Socket.id/1."},{"ref":"ComboWeb.GraphQL.SessionErrorHandler.html","title":"ComboWeb.GraphQL.SessionErrorHandler","type":"module","doc":""},{"ref":"ComboWeb.GraphQL.SessionErrorHandler.html#build_error_response/3","title":"ComboWeb.GraphQL.SessionErrorHandler.build_error_response/3","type":"function","doc":""}]